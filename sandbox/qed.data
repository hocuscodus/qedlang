/$
// The QED programming language (library)
// Copyright (C) 2024  Hocus Codus Software
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

class QEDObject {
  blocking__Call = null;
  active = true;

  constructor(context__Call) {
    this.context__Call = context__Call;
  }

  _qedSetBlockingCall(blockingCall) {
    if (!this.blocking__Call) {
      this.blocking__Call = blockingCall;
      this.blocking__Call.refreshLevel = 3;
    }
  }

  _qedKill() {
    if (this.active) {
      this.active = false;
      this._qedEndCall();
    }
  }

  _qedEndCall() {
    if (this.blocking__Call) {
      this.blocking__Call._qedKill();
      this.blocking__Call = null;
      this.refreshLevel = 1;
    }
  }

  _isActive() {
    return this.active && (!this.context__Call || this.context__Call._isActive());
  }

  _refreshModels() {
    let level = this.refresh_Model_ ? this.refresh_Model_() : 0;

    if (this.blocking__Call)
      level = Math.max(level, this.blocking__Call._refreshModels());

    return level;
  }
}

class QEDBasicArray extends Array {
  constructor() {
    super();
  }

  _refreshModels = function() {
    let level = 0;

    for (let index = 0; index < this.length; index++)
      level = Math.max(level, this[index]._refreshModels());

    return level;
  }
}

var canvas = document.getElementById("canvas");
let postHandler = null;
let attributeStacks = [];
let ctx = canvas.getContext("2d");
const pointerSupported = !!window.PointerEvent

canvas.addEventListener(pointerSupported ? "pointerdown" : "mouseDown", function(ev) {
  var rect = canvas.getBoundingClientRect();
  const mouseX = event.clientX - rect.left;
  const mouseY = event.clientY - rect.top;
  const canvasX = mouseX * canvas.width / canvas.clientWidth;
  const canvasY = mouseY * canvas.height / canvas.clientHeight;

  Main_$this.onGlobalEvent(0, [canvasX, canvasY]);
});
canvas.addEventListener(pointerSupported ? "pointerup" : "mouseUp", function(ev) {
  var rect = canvas.getBoundingClientRect();
  const mouseX = event.clientX - rect.left;
  const mouseY = event.clientY - rect.top;
  const canvasX = mouseX * canvas.width / canvas.clientWidth;
  const canvasY = mouseY * canvas.height / canvas.clientHeight;

  Main_$this.onGlobalEvent(1, [canvasX, canvasY]);
});
if (pointerSupported)
  canvas.addEventListener("pointercancel", function(ev) {
    var rect = canvas.getBoundingClientRect();
    Main_$this.onGlobalEvent(1, [ev.clientX - rect.left, ev.clientY - rect.top]);
  });
canvas.onselectstart = function () { return false; }$/
/$if (!String.prototype.padStart) {
    String.prototype.padStart = function padStart(targetLength, padString) {
    targetLength = targetLength >> 0; //floor if number or convert non-number to 0;
    padString = String(padString || ' ');
    if (this.length > targetLength) {
        return String(this);
    } else {
        targetLength = targetLength - this.length;
        if (targetLength > padString.length) {
            padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed
        }
        return padString.slice(0, targetLength) + String(this);
    }
}
}

let _currentRadius = 3.0;
let _strokeFlag = false;
let _fillFlag = true;
let _lineFlag = false;
ctx.font = "20px 'Arial'";
ctx.fillStyle = "black";
ctx.strokeStyle = "black";
ctx.globalAlpha = 1.0;$/

/$function _bindHandler(obj, handler) {
  obj._HandlerFn_ = handler;
  return obj;
}

function _qedCallback(obj, value) {
  if (obj._HandlerFn_) {
    obj._HandlerFn_(value);
    Main_$this.executeEvents_();
  }
}$/

int QED_TAG_OUT = 0
int QED_TAG_SIZE = 1
int QED_TAG_ID = 2
int QED_TAG_AREA_HERITABLE = 3
int QED_TAG_FONT = 4
int QED_TAG_FONT_SIZE = 5
int QED_TAG_SPACING = 6
int QED_TAG_AREA_END = 7
int QED_TAG_ALIGN = 8
int QED_TAG_EXPAND = 9
int QED_TAG_POS = 10
int QED_TAG_HERITABLE = 11
int QED_TAG_FILL_STYLE = 12
int QED_TAG_STROKE_STYLE = 13
int QED_TAG_LINE_WIDTH = 14
int QED_TAG_OPACITY = 15
int QED_TAG_RADIUS = 16
int QED_TAG_ROTATION = 17
int QED_TAG_END = 18

float _spacing = 0.0;
float _fontSize = 20;

void voidHandler_() {}
void VoidHandler_() {}
void anyHandler_(var value) {}
void intHandler_(int value) {}
void floatHandler_(float value) {}
void boolHandler_(bool value) {}
void stringHandler_(String value) {}

bool QedYield() {
  voidHandler_ processFn = (void l() {
    /$QedYield$this.processFn = null;
    if (QedYield$this._HandlerFn_)
      QedYield$this._HandlerFn_(true)$/
  })
}
bool qedResume(var obj) {
/$if (obj instanceof Array) {
    let size = obj.size();
    let oneItem = false;

    for (let index = 0; index < size; index++)
      oneItem |= this.qedResume(obj[index]);

    return oneItem;
  }
  else
    if (obj.blocking__Call)
      return this.qedResume(obj.blocking__Call)
    else
      if (obj.processFn) {
        obj.processFn();
        return true;
      }
      else
        return false;$/
}
void println(var str) {
/$console.log(str)$/
}
void post_(var obj, var ret) {
/$if (postHandler != null)
    console.log("postHandler not null");

  postHandler = [obj, ret]$/
}
void post_(voidHandler_ handler) {
/$if (postHandler != null)
    console.log("postHandler not null");

  postHandler = handler$/
}
int refreshCount = 1
bool autoResize = true
bool autoInit = false
Window_[] windows;
var MainObj;
void _refresh(var obj, int x, int y, int width, int height) {
/$let level = obj._refreshModels();
//  console.log("" + refreshCount++ + "- Refresh Level: " + level);

//  if (level) {
    ctx.globalAlpha = 1.0;

//    if (level >= 2) {
      Main_$this.windows = _refreshViews(obj);

      if (Main_$this.windows.length) {
        width = Main_$this.windows[0].size[0];
        height = Main_$this.windows[0].size[1];
      }
      else
        width = height = 0;
//    }

    if (!Main_$this.autoInit) {
      Main_$this.autoResize = canvas.width == 0 && canvas.height == 0;
      Main_$this.autoInit = true;
    }

    if (Main_$this.autoResize && (canvas.width != width || canvas.height != height)) {
      canvas.width = width;
      canvas.height = height;
      ctx = canvas.getContext("2d");
      ctx.font = "20px 'Arial'";
      ctx.fillStyle = "black";
      ctx.strokeStyle = "black";
      ctx.globalAlpha = 1.0;
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (Main_$this.windows.length)
      Main_$this.windows[0].paint(x, y, canvas.width, canvas.height);
//  }
$/
}
int[] getBounds(String[] path, int[] index) {
/$return Main_$this.windows.length ? Main_$this.windows[0].getBoundsRect(path, index, 0, 0, canvas.width, canvas.height, 0, 0) : []$/
}
void executeEvents_() {
/$while (postHandler != null)
    if (postHandler instanceof Array) {
      const obj = postHandler[0];
      const ret = postHandler[1];
    
      postHandler = null;

      if (obj._HandlerFn_)
        obj._HandlerFn_(ret);
    } else {
      const handler = postHandler;
    
      postHandler = null;
      handler();
    }

  if (this.MainObj)
    _refresh(this.MainObj, 0, 0, canvas.width, canvas.height);
  else
    ctx.clearRect(0, 0, canvas.width, canvas.height);$/
}
bool qedEqual(var value1, var value2) {
  bool equal = value1 == value2

/$  if (!equal && value1 instanceof Array && value2 instanceof Array) {
    equal = (value1.length == value2.length) && value1.every(function(element, index) {
        return Main_$this.qedEqual(element, value2[index]); 
    });
  }$/

  return equal
}
int max(int a, int b) {
/$return a > b ? a : b$/
}
int min(int a, int b) {
/$return a < b ? a : b$/
}
int abs(int a) {
/$return Math.abs(a)$/
}
float rand() {
/$return Math.random()$/
}
int trunc(float n) {
/$return Math.trunc(n)$/
}
float clock() {}
void saveContext() {
/$ctx.save();
  ctx.clip();$/
}
void restoreContext() {
/$ctx.restore()$/
}
void rotate(int x, int y, int width, int height, float angle) {
/$ctx.save()$/
/$ctx.translate(x + width / 2, y + height / 2)$/
/$ctx.rotate(angle)$/
}
void qedDraw() {
  if (/$_fillFlag$/)
    /$ctx.fill()$/

  if (/$_strokeFlag$/ && /$_lineFlag$/)
    /$ctx.stroke()$/
}
void drawFn(int x, int y, int width, int height) {}
void oval(int x, int y, int width, int height) {
/$ctx.beginPath();
  ctx.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2*Math.PI)$/
  qedDraw()
}
void rect(int x, int y, int width, int height) {
/$ctx.beginPath();
  ctx.rect(x, y, width, height)$/
  qedDraw()
}
void roundRect(int x, int y, int width, int height) {
/$let radius = _currentRadius;/*
  let radiusy = Math.min(radius, height / 2);
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.quadraticCurveTo(x, y, x, y + radiusy);
  if (height > 2 * radiusy)
    ctx.lineTo(x, y + height - radiusy)
  ctx.quadraticCurveTo(x, y + height, x + radius, y + height);
  ctx.lineTo(x + width - radius, y + height)
  ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radiusy);
  if (height > 2 * radiusy)
    ctx.lineTo(x + width, y + radiusy);
  ctx.quadraticCurveTo(x + width, y, x + width - radius, y);
  ctx.lineTo(x + radius, y);*/
ctx.beginPath();
ctx.moveTo(x + radius, y);
ctx.lineTo(x + width - radius, y);
ctx.arcTo(x + width, y, x + width, y + radius, radius);
ctx.lineTo(x + width, y + height - radius);
ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
ctx.lineTo(x + radius, y + height);
ctx.arcTo(x, y + height, x, y + height - radius, radius);
ctx.lineTo(x, y + radius);
ctx.arcTo(x, y, x + radius, y, radius)$/
  qedDraw()
}
var getAttribute(int index) {
/$return attributeStacks[index][attributeStacks[index].length - 1]$/
}
void _qedPushAttribute(int index, var value) {
/$let oldValue;

  switch(index) {
    case Main_$this.QED_TAG_FONT:
      oldValue = ctx.font;
      ctx.font = value;
      break;

    case Main_$this.QED_TAG_FONT_SIZE:
      oldValue = [ctx.font, _fontSize];
      _fontSize = value;
      ctx.font = value + "px Arial";
      break;

    case Main_$this.QED_TAG_SPACING:
      oldValue = _spacing;
      _spacing = value;
      break;

    case Main_$this.QED_TAG_FILL_STYLE:
      oldValue = [_fillFlag, ctx.fillStyle];
      _fillFlag = value !== "none"

      if (_fillFlag)
        ctx.fillStyle = value;
      break;

    case Main_$this.QED_TAG_STROKE_STYLE:
      oldValue = [_strokeFlag, ctx.strokeStyle];
      _strokeFlag = value !== "none"

      if (_strokeFlag)
        ctx.strokeStyle = value;
      break;

    case Main_$this.QED_TAG_LINE_WIDTH:
      oldValue = [_lineFlag, ctx.lineWidth];
      _lineFlag = value !== "none"

      if (_lineFlag)
        ctx.lineWidth = value;
      break;

    case Main_$this.QED_TAG_OPACITY:
      oldValue = ctx.globalAlpha;
      ctx.globalAlpha = value;
      break;

    case Main_$this.QED_TAG_RADIUS:
      oldValue = _currentRadius;
      _currentRadius = value;
      break;

    case Main_$this.QED_TAG_ROTATION:
      break;
  }

  if (attributeStacks[index] == undefined)
    attributeStacks[index] = [];

  attributeStacks[index].push(oldValue)$/
}
void pushAttribute(int index, int value) {
  _qedPushAttribute(index, value)
}
void pushAttribute(int index, float value) {
  _qedPushAttribute(index, value)
}
void pushAttribute(int index, String value) {
  _qedPushAttribute(index, value)
}
void popAttribute(int index) {
/$const value = attributeStacks[index].pop();

  switch(index) {
    case Main_$this.QED_TAG_FONT:
      ctx.font = value;
      break;

    case Main_$this.QED_TAG_FONT_SIZE:
      _fontSize = value[1];
      ctx.font = value[0];
      break;

    case Main_$this.QED_TAG_SPACING:
      _spacing = value;
      break;

    case Main_$this.QED_TAG_FILL_STYLE:
      _fillFlag = value[0];

      if (_fillFlag)
        ctx.fillStyle = value[1];
      break;

    case Main_$this.QED_TAG_STROKE_STYLE:
      _strokeFlag = value[0];

      if (_strokeFlag)
        ctx.strokeStyle = value[1];
      break;

    case Main_$this.QED_TAG_LINE_WIDTH:
      _lineFlag = value[0]

      if (_lineFlag)
        ctx.lineWidth = value;
      break;

    case Main_$this.QED_TAG_OPACITY:
      ctx.globalAlpha = value;
      break;

    case Main_$this.QED_TAG_RADIUS:
      _currentRadius = value;
      break;

    case Main_$this.QED_TAG_ROTATION:
      break;
  }$/
}
int[] getTextSize(String text) {
/$const textSize = ctx.measureText(text);
  const height = textSize.fontBoundingBoxAscent + textSize.fontBoundingBoxDescent;
  return [textSize.width, height]$/
}
void displayText(String text, int x, int y, int width, int height) {
/$ctx.textBaseline = "top";
  ctx.fillText(text, x, y)$/
}

void QedImage() {
  var img = /$new Image()$/
}
int[] getImageSize(QedImage image) {
/$return [image.img.naturalWidth, image.img.naturalHeight]$/
}
void displayImage(QedImage image, int x, int y, int width, int height) {
/$if (image.img.complete && image.img.naturalWidth > 0)
  ctx.drawImage(image.img, x, y)$/
}

bool QedTimer(int timeoutMillis) {
/$setTimeout(function() {
    _qedCallback(QedTimer$this, true);
  }, timeoutMillis)$/

  void reset() {}
}
void Time(voidHandler_ *Func) {
/$console.time("Time");
  new Func(() => {
    console.timeEnd("Time");
    _qedCallback(Time$this, null);
  })$/
}
void time(voidHandler_ *func) {
/$  console.time("time");
  func();
  console.timeEnd("time")$/
}
int QedAnimation() {
/$requestAnimationFrame((timeStampMs) => {
    _qedCallback(QedAnimation$this, timeStampMs);
  })$/
}

void QedButtonContent(bool[] pressed) {<out:"";>}

void QedGenericButton(QedButtonContent *ContentFn) {
  bool[] pressed = [false]
  QedButtonContent content = new ContentFn(pressed)

  <out: content;
   onPress: {pressed[0] = true; _captureFocus();}
   onRelease: {pressed[0] = false; _releaseFocus(); return}
  >
}

String QedLinkButton(String text) {
  var button = new QedGenericButton((void L(bool[] pressed) {
    <out: text; opacity: pressed[0] ? 35% : 100%;>
  })) -> return text

  <out: button;>
}

void QedRectButton(VoidHandler_ *ContentFn) {
  VoidHandler_ content = new ContentFn()
  var button = new QedGenericButton((void L(bool[] pressed) {
    <out: roundRect;
      <out: rect; opacity: pressed[0] ? 35% : 0%; fillStyle: "black";>
      <out: content;>
    >
  })) -> return

  <out: button;>
}

String QedTextButton(String text) {
  String _textStyle = "white"
  float _textOpacity = 1;

  QedTextButton textStyle(String style) {_textStyle = style; return /$this$/;}
  QedTextButton textOpacity(float opacity) {_textOpacity = opacity; return /$this$/;}

  var button = new QedRectButton((void L() {
    <\expand: 100%;
      <size: ((int) _fontSize) * 0.2; expand: 1;>
      <out: text; fillStyle: _textStyle; opacity: _textOpacity;>
      <size: ((int) _fontSize) * 0.2; expand: 1;>
    >
  })) -> return text

  <out: button;>
}

void QEDBaseArray_() {
  int getNumDirs() {return 0;}
  int[] getDirs(int childDir) {return [0, 0];}
  int size() {return 0;}
  var insert(int[] pos, int[] size) {}
  var Insert(int[] pos, int[] size) {}
  var push() {}
  var Push() {}
  var pop() {}
  var get(int[] pos) {}
  void set(int[] pos, var value) {}
  var get(int index) {}
  void set(int index, var value) {}
  Directive_ qedModel;
  int refresh_Model_() {
  }
}

var InitFn(int[] pos) {}
void Qui_(var array, int[] dims) {}

var SQEDArray(InitFn *Init, int numDim, int[] dirs, Qui_ *Ui_) {
  /$this.dims = new Array(numDim).fill(0)$/
  return /$SQEDArray$this$/

  int size() {
    int s = 1

    for (int index = /$this.dims.length - 1$/; index >= 0; index--)
      s *= /$this.dims[index]$/

    return s
  }

  var insert(int[] pos, int[] size) {
    // runtime error
    return /$null$/
  }

  var Insert(int[] pos, int[] size) {
    int[] newSize = /$[...this.size]$/

    for (int index = /$SQEDArray$this.dims.length - 1$/; index >= 0; index--)
      newSize[index] += /$SQEDArray$this.dims[index]$/

    InsertLevel(/$SQEDArray$this$/, /$SQEDArray$this.dims$/, pos, size, newSize, /$new Array(this.size.length).fill(0)$/, 0)
    /$SQEDArray$this.dims$/ = newSize
    return /$this$/
  }

  var remove(int[] pos, int[] size) {
    int[] newSize = /$[...SQEDArray$this.dims]$/

    for (int index = /$SQEDArray$this.dims.length - 1$/; index >= 0; index--)
      newSize[index] -= /$size[index]$/

    removeLevel(/$SQEDArray$this$/, /$SQEDArray$this.dims$/, pos, size, newSize, /$new Array(size.length).fill(0)$/, 0)
    /$SQEDArray$this.dims$/ = newSize
    return /$this$/
  }

  void InsertLevel(var array, var dims, int[] pos, int[] size, int[] newSize, var pp, int level) {
    if (level < /$SQEDArray$this.dims.length - 1$/) {
      for (/$pp[level] = 0$/; /$pp[level] < pos[level]$/; /$pp[level]++$/)
        InsertLevel(/$array[pp[level]]$/, dims, pos, size, newSize, pp, level + 1)

      if (size[level] != 0)
        for (/$pp[level] = dims[level] - 1$/; /$pp[level] >= pos[level]$/; /$pp[level]--$/)
          /$array[pp[level] + InsertLevel$this.size[level]] = array[pp[level]]$/

      for (/$pp[level] = pos[level]$/; /$pp[level] < pos[level] + InsertLevel$this.size[level]$/; /$pp[level]++$/) {
        /$array[pp[level]] = []$/
        InsertLevel(/$array[pp[level]]$/, /$new Array(InsertLevel$this.size.length).fill(0)$/, /$new Array(InsertLevel$this.size.length).fill(0)$/, newSize, newSize, pp, level + 1)
      }

      for (/$pp[level] = pos[level] + InsertLevel$this.size[level]$/; /$pp[level] < newSize[level]$/; /$pp[level]++$/)
        InsertLevel(/$array[pp[level]]$/, dims, pos, size, newSize, pp, level + 1)
    }
    else {
      if (size[level] != 0)
        for (/$pp[level] = dims[level] - 1$/; /$pp[level] >= pos[level]$/; /$pp[level]--$/)
          /$array[pp[level] + InsertLevel$this.size[level]] = array[pp[level]]$/

      for (/$pp[level] = pos[level]$/; /$pp[level] < pos[level] + InsertLevel$this.size[level]$/; /$pp[level]++$/)
        /$array[pp[level]]$/ = Init(pp)
    }
    return;
  }

  void removeLevel(var array, var dims, int[] pos, int[] size, int[] newSize, var pp, int level) {
    if (level < /$SQEDArray$this.dims.length - 1$/) {
      for (/$pp[level] = dims[level] - 1$/; /$pp[level] >= pos[level] + size[level]$/; /$pp[level]--$/)
        removeLevel(/$array[pp[level]]$/, dims, pos, size, newSize, pp, level + 1)

      if (size[level] != 0)
        for (/$pp[level] = pos[level]$/; /$pp[level] < newSize[level]$/; /$pp[level]++$/)
          /$array[pp[level]] = array[pp[level] + size[level]]$/

      for (/$pp[level] = pos[level] - 1$/; /$pp[level] >= 0$/; /$pp[level]--$/)
        removeLevel(/$array[pp[level]]$/, dims, pos, size, newSize, pp, level + 1)
    }
    else
      if (size[level] != 0)
        for (/$pp[level] = pos[level]$/; /$pp[level] < newSize[level]$/; /$pp[level]++$/)
          /$array[pp[level]] = array[pp[level] + size[level]]$/

    return;
  }

  var push() {
    // runtime error
    return /$null$/
  }

  var Push() {
    int[] pos = /$new Array(SQEDArray$this.dims.length).fill(0)$/
    int[] size = /$new Array(SQEDArray$this.dims.length).fill(0)$/

    pos[0] = /$SQEDArray$this.dims[0]$/
    size[0] = 1
    Insert(pos, size)
    return /$this$/
  }

  var pop() {
    int[] pos = /$new Array(SQEDArray$this.dims.length).fill(0)$/
    int[] size = /$new Array(SQEDArray$this.dims.length).fill(0)$/

    pos[0] = /$SQEDArray$this.dims[0] - 1$/
    size[0] = 1
    remove(pos, size)
    return /$this$/
  }
}

void VInitFn(int[] pos) {}

var VSQEDArray(VInitFn *Init, int numDim) {
  /$this.dims = new Array(numDim).fill(0)$/
  return /$VSQEDArray$this$/

  int size() {
    int s = 1

    for (int index = /$this.dims.length - 1$/; index >= 0; index--)
      s *= /$this.dims[index]$/

    return s
  }

  var insert(int[] pos, int[] size) {
    // runtime error
    return /$null$/
  }

  var Insert(int[] pos, int[] size) {
    int[] newSize = /$[...this.size]$/

    for (int index = /$VSQEDArray$this.dims.length - 1$/; index >= 0; index--)
      newSize[index] += /$VSQEDArray$this.dims[index]$/;

    InsertLevel(/$VSQEDArray$this.dims$/, pos, size, newSize, /$new Array(this.size.length).fill(0)$/, 0)
    /$VSQEDArray$this.dims$/ = newSize
    return /$this$/
  }

  void InsertLevel(var dims, int[] pos, int[] size, int[] newSize, var pp, int level) {
    if (level < /$VSQEDArray$this.dims.length - 1$/) {
      for (/$pp[level] = 0$/; /$pp[level] < pos[level]$/; /$pp[level]++$/)
        InsertLevel(dims, pos, size, newSize, pp, level + 1)

      for (/$pp[level] = pos[level]$/; /$pp[level] < pos[level] + InsertLevel$this.size[level]$/; /$pp[level]++$/) {
        /$array[pp[level]] = []$/
        InsertLevel(/$new Array(InsertLevel$this.size.length).fill(0)$/, /$new Array(InsertLevel$this.size.length).fill(0)$/, newSize, newSize, pp, level + 1)
      }

      for (/$pp[level] = pos[level] + InsertLevel$this.size[level]$/; /$pp[level] < newSize[level]$/; /$pp[level]++$/)
        InsertLevel(dims, pos, size, newSize, pp, level + 1)
    }
    else
      for (/$pp[level] = pos[level]$/; /$pp[level] < pos[level] + InsertLevel$this.size[level]$/; /$pp[level]++$/)
        Init(pp)

    return;
  }
}

var sInitFn(int[] pos) {}

var QEDArray(sInitFn *init, int numDim, int[] dirs, Qui_ *Ui_) {
  int getNumDirs() {return numDim;}
  int[] getDirs(int childDir) {return dirs;}
  /$this.dims = new Array(numDim).fill(0)$/

  int size() {
    int s = 1

    for (int index = /$this.dims.length - 1$/; index >= 0; index--)
      s *= /$this.dims[index]$/

    return s
  }

  var insert(int[] pos, int[] size) {
    int[] newSize = /$[...size]$/

    for (int index = /$QEDArray$this.dims.length - 1$/; index >= 0; index--)
      newSize[index] += /$QEDArray$this.dims[index]$/

    insertLevel(/$QEDArray$this$/, /$QEDArray$this.dims$/, pos, size, newSize, /$new Array(size.length).fill(0)$/, 0)
    /$QEDArray$this.dims$/ = newSize
    return /$this$/
  }

  var remove(int[] pos, int[] size) {
    int[] newSize = /$[...QEDArray$this.dims]$/

    for (int index = /$QEDArray$this.dims.length - 1$/; index >= 0; index--)
      newSize[index] -= /$size[index]$/

    removeLevel(/$QEDArray$this$/, /$QEDArray$this.dims$/, pos, size, newSize, /$new Array(size.length).fill(0)$/, 0)
    /$QEDArray$this.dims$/ = newSize
    return /$this$/
  }

  void insertLevel(var array, var dims, int[] pos, int[] size, int[] newSize, var pp, int level) {
    if (level < /$QEDArray$this.dims.length - 1$/) {
      for (/$pp[level] = 0$/; /$pp[level] < pos[level]$/; /$pp[level]++$/)
        insertLevel(/$array[pp[level]]$/, dims, pos, size, newSize, pp, level + 1)

      if (size[level] != 0)
        for (/$pp[level] = dims[level] - 1$/; /$pp[level] >= pos[level]$/; /$pp[level]--$/)
          /$array[pp[level] + size[level]] = array[pp[level]]$/

      for (/$pp[level] = pos[level]$/; /$pp[level] < pos[level] + size[level]$/; /$pp[level]++$/) {
        /$array[pp[level]] = []$/
        insertLevel(/$array[pp[level]]$/, /$new Array(size.length).fill(0)$/, /$new Array(size.length).fill(0)$/, newSize, newSize, pp, level + 1)
      }

      for (/$pp[level] = pos[level] + size[level]$/; /$pp[level] < newSize[level]$/; /$pp[level]++$/)
        insertLevel(/$array[pp[level]]$/, dims, pos, size, newSize, pp, level + 1)
    }
    else {
      if (size[level] != 0)
        for (/$pp[level] = dims[level] - 1$/; /$pp[level] >= pos[level]$/; /$pp[level]--$/)
          /$array[pp[level] + size[level]] = array[pp[level]]$/

      for (/$pp[level] = pos[level]$/; /$pp[level] < pos[level] + size[level]$/; /$pp[level]++$/) {
        int index = /$pp[level]$/
        /$array[pp[level]]$/ = init(pp)
      }
    }
    return;
  }

  void removeLevel(var array, var dims, int[] pos, int[] size, int[] newSize, var pp, int level) {
    if (level < /$QEDArray$this.dims.length - 1$/) {
      for (/$pp[level] = dims[level] - 1$/; /$pp[level] >= pos[level] + size[level]$/; /$pp[level]--$/)
        removeLevel(/$array[pp[level]]$/, dims, pos, size, newSize, pp, level + 1)

      if (size[level] != 0)
        for (/$pp[level] = pos[level]$/; /$pp[level] < newSize[level]$/; /$pp[level]++$/)
          /$array[pp[level]] = array[pp[level] + size[level]]$/

      for (/$pp[level] = pos[level] - 1$/; /$pp[level] >= 0$/; /$pp[level]--$/)
        removeLevel(/$array[pp[level]]$/, dims, pos, size, newSize, pp, level + 1)
    }
    else
      if (size[level] != 0)
        for (/$pp[level] = pos[level]$/; /$pp[level] < newSize[level]$/; /$pp[level]++$/)
          /$array[pp[level]] = array[pp[level] + size[level]]$/

    return;
  }

  var push() {
    int[] pos = /$new Array(QEDArray$this.dims.length).fill(0)$/
    int[] size = /$new Array(QEDArray$this.dims.length).fill(0)$/

    pos[0] = /$QEDArray$this.dims[0]$/
    size[0] = 1
    insert(pos, size)
    return /$this$/
  }

  var Push() {
    return push()
  }

  var pop() {
    int[] pos = /$new Array(QEDArray$this.dims.length).fill(0)$/
    int[] size = /$new Array(QEDArray$this.dims.length).fill(0)$/

    pos[0] = /$QEDArray$this.dims[0] - 1$/
    size[0] = 1
    remove(pos, size)
    return /$this$/
  }
}

void vInitFn(int[] pos) {}

void VQEDArray(vInitFn *init, int numDim) {
  /$this.dims = new Array(numDim).fill(0)$/

  int size() {
    int s = 1

    for (int index = /$this.dims.length - 1$/; index >= 0; index--)
      s *= /$this.dims[index]$/

    return s
  }

  var insert(int[] pos, int[] size) {
    int[] newSize = /$[...size]$/

    for (int index = /$VQEDArray$this.dims.length - 1$/; index >= 0; index--)
      newSize[index] += /$VQEDArray$this.dims[index]$/

    insertLevel(/$VQEDArray$this.dims$/, pos, size, newSize, /$new Array(size.length).fill(0)$/, 0)
    /$VQEDArray$this.dims$/ = newSize
    return /$this$/
  }

  void insertLevel(var dims, int[] pos, int[] size, int[] newSize, var pp, int level) {
    if (level < /$VQEDArray$this.dims.length - 1$/) {
      for (/$pp[level] = 0$/; /$pp[level] < pos[level]$/; /$pp[level]++$/)
        insertLevel(dims, pos, size, newSize, pp, level + 1)

      for (/$pp[level] = pos[level]$/; /$pp[level] < pos[level] + size[level]$/; /$pp[level]++$/)
        insertLevel(/$new Array(size.length).fill(0)$/, /$new Array(size.length).fill(0)$/, newSize, newSize, pp, level + 1)

      for (/$pp[level] = pos[level] + size[level]$/; /$pp[level] < newSize[level]$/; /$pp[level]++$/)
        insertLevel(dims, pos, size, newSize, pp, level + 1)
    }
    else
      for (/$pp[level] = pos[level]$/; /$pp[level] < pos[level] + size[level]$/; /$pp[level]++$/)
        init(pp)

    return;
  }
}

/$this.QEDExplicitArray = class QEDExplicitArray extends QEDBasicArray {
  constructor(...args) {
    super();
    for (const arg of args)
      this.push(arg);
  }

  getNumDirs() {return 1;}
  getDirs(childDir) {return [childDir & 1, (childDir & 2) ? 1 : 0];}
  size() {return this.length;}
}$/

var resizeView(var unit) {}
int[] getViewSize(var viewObj) {}
void paintView(var unit, var viewObj, int posx, int posy, int sizex, int sizey) {}
bool onViewEvent(var viewObj, int event, int posx, int posy, int sizex, int sizey) {}
int[] getViewElementRect(var viewObj, String[] path, int[] index, int posx, int posy, int sizex, int sizey, int level, int dLevel) {}

void ViewArray_(QEDBaseArray_[] array, int[] dirs, resizeView *resizeViewFn, getViewSize *getViewSizeFn, paintView *paintViewFn, onViewEvent *onViewEventFn, getViewElementRect *getViewElementRectFn) {
  float space = /$_spacing$/
  int length = array.size()
  var[] views = /$[]$/
  int[][] posSet = /$[]$/
  int[] size = [0, 0]

  for (int index = 0; index < length; index++) {
    views[index] = resizeViewFn(array[index])
    posSet[index] = [0, 0]

    int[] elementSize = getViewSizeFn(views[index]);

    for (int dir = 0; dir < 2; dir++) {
      posSet[index][dir] = dirs[dir] ? (index ? size[dir] + space : 0) + elementSize[dir] : max(size[dir], elementSize[dir]);
      size[dir] = posSet[index][dir];
    }
  }

  void paint(int pos0, int pos1, int size0, int size1) {
    int[] newPos = [pos0, pos1]
    int[] pos = [pos0, pos1]
    int[] size = [size0, size1]

    for (int index = 0; index < length; index++) {
      for (int dir = 0; dir < 2; dir++)
        if (dirs[dir]) {
          int relPos = index ? posSet[index - 1][dir] + space : 0

          pos[dir] = newPos[dir] + relPos
          size[dir] = posSet[index][dir] - relPos
        }

      paintViewFn(array[index], views[index], pos[0], pos[1], size[0], size[1])
    }
  }

  bool onEvent(int event, int pos0, int pos1, int size0, int size1) {
    int[] pos = [0, 0];
    int[] size = [size0, size1];

    for (int index = length - 1; index >= 0; index--) {
      for (int dir = 0; dir < 2; dir++)
        if (dirs[dir]) {
          pos[dir] = index ? posSet[index - 1][dir] + space : 0
          size[dir] = posSet[index][dir] - pos[dir]
        }

      if (pos0 >= pos[0] && pos0 < pos[0] + size[0] && pos1 >= pos[1] && pos1 < pos[1] + size[1]) {
        pos0 -= pos[0]
        pos1 -= pos[1]

        return onViewEventFn(views[index], event, pos0, pos1, size[0], size[1])
      }
    }

    return false
  }

  int[] getBoundsRect(String[] path, int[] index, int pos0, int pos1, int size0, int size1, int level, int dLevel) {
    int ndx = index[0]
    int relPos = ndx ? posSet[ndx - 1][0] + space : 0
    int posx = pos0 + relPos
    int posy = pos1
    int sizex = posSet[ndx][0] - relPos
    int sizey = size1

    dLevel++
    if (level < path.size() || dLevel < index.size())
      return getViewElementRectFn(views[ndx], path, index, posx, posy, sizex, sizey, level, dLevel)
    else
      return [posx, posy, sizex, sizey]
  }
}

var resizeViewObj(var unit) {
  QEDBaseArray_ value = unit
  return _refreshViews(value)
}
int[] getViewSizeObj(var viewObj) {
  Window_[] window = /$viewObj$/

  return window.size() ? /$window[0].size$/ : [0, 0]
}
void paintViewObj(var unit, var viewObj, int posx, int posy, int sizex, int sizey) {
  Window_[] window = /$viewObj$/

  if (window.size())
    window[0].paint(posx, posy, sizex, sizey)
}
bool onViewEventObj(var viewObj, int event, int posx, int posy, int sizex, int sizey) {
  Window_[] window = /$viewObj$/

  return window.size() && window[0].onEvent(event, [posx, posy], [sizex, sizey])
}
int[] getViewElementRectObj(var viewObj, String[] path, int[] index, int pos0, int pos1, int size0, int size1, int level, int dLevel) {
  Window_[] window = /$viewObj$/

  return window.size() ? window[0].getBoundsRect(path, index, pos0, pos1, size0, size1, level, dLevel) : []
}

var resizeViewString(var unit) {
  return getTextSize(unit)
}
int[] getViewSizeString(var viewObj) {
  return /$viewObj$/
}
void paintViewString(var unit, var viewObj, int posx, int posy, int sizex, int sizey) {
  int[] size = /$viewObj$/
  displayText(unit, posx, posy, sizex, sizey)
}
bool onViewEventString(var viewObj, int event, int posx, int posy, int sizex, int sizey) {
  return true// viewObj.onEvent(event, posx, posy, sizex, sizey)
}
int[] getViewElementRectString(var viewObj, String[] path, int[] index, int posx, int posy, int sizex, int sizey, int level, int dLevel) {
  int[] size = /$viewObj$/
  return size
}

var resizeViewImage(var unit) {
  return getImageSize(unit)
}
int[] getViewSizeImage(var viewObj) {
  return /$viewObj$/
}
void paintViewImage(var unit, var viewObj, int posx, int posy, int sizex, int sizey) {
  int[] size = /$viewObj$/
  displayImage(unit, posx, posy, sizex, sizey)
}
bool onViewEventImage(var viewObj, int event, int posx, int posy, int sizex, int sizey) {
  return true// viewObj.onEvent(event, posx, posy, sizex, sizey)
}
int[] getViewElementRectImage(var viewObj, String[] path, int[] index, int posx, int posy, int sizex, int sizey, int level, int dLevel) {
  int[] size = /$viewObj$/
  return size
}

void Attr_(int code, int outNumDim, int outType, var value) {
}

// viewIndex = -1 -> non-sized unit or group
// viewIndex = 0  -> sized group
// viewIndex = 1  -> sized unit, has an associated variable
void Directive_(int direction, Attr_[] atts, Directive_[] children) {
//  Directive_[] children = []
  Attr_[] sizeAttr = []
  Attr_[] outAttr = []
  int viewIndex = 0
  bool childrenViewFlag = false
  // 0 - no change
  // 1 - to repaint
  // 2 - to resize
  // 3 - to recreate
  int changeLevel = 0
  int subChangeLevel = 0
  int outType = -1
  int outNumDim = 0

  for (int ndx = 0; ndx < atts.size(); ndx++) {
    Attr_ attr = atts[ndx]

    if (attr.code == QED_TAG_SIZE)
      sizeAttr = [attr]

    if (attr.code == QED_TAG_OUT) {
      outAttr = [attr]
      outNumDim = attr.outNumDim
      outType = attr.outType
    }
  }

  if (sizeAttr.size() || (!outNumDim && outType > 0/*OBJ_INSTANCE*/))
    viewIndex = 1
  else
    if (outType >= 0)
      viewIndex = -1

  for (int ndx = 0; !childrenViewFlag && ndx < children.size(); ndx++)
    childrenViewFlag = hasAreas(children[ndx]);

  void clearChange() {
    changeLevel = 0

    for (int index = 0; index < children.size(); index++)
      children[index].clearChange()
  }

  int refreshChange() {
    subChangeLevel = 0

    for (int index = 0; index < children.size(); index++)
      subChangeLevel = max(subChangeLevel, children[index].refreshChange())

//    return max(changeLevel, sizeAttr.size() ? min(subChangeLevel, 1) : subChangeLevel)
    changeLevel = max(changeLevel, subChangeLevel)
    return changeLevel
  }

  void setAtt(int index, var value) {
    Attr_ att = atts[index]

    if (!qedEqual(value, att.value)) {
      changeLevel = max(changeLevel, att.code > QED_TAG_HERITABLE ? 1 : att.code > QED_TAG_AREA_HERITABLE ? 2 : 3)
      atts[index].value = value
    }
  }

  Attr_[] findAttr(int code) {
    for (int index = 0; index < atts.size(); index++)
      if (atts[index].code == code)
        return [atts[index]]

    return [];
  }

  int getChangeLevel() {
    return changeLevel
  }

  void refreshSubModel() {
    var subModel = outAttr[0].value

    if (/$subModel != null$/)
      changeLevel = max(changeLevel, /$subModel._refreshModels()$/)
  }
}

bool hasAreas(Directive_ directive) {
  return directive.childrenViewFlag || directive.viewIndex;
}

bool isAreaHeritable(int code) {
  return code > QED_TAG_AREA_HERITABLE && code < QED_TAG_AREA_END
}

bool isHeritable(int code) {
  return isAreaHeritable(code) || (code > QED_TAG_HERITABLE && code < QED_TAG_END);
}

var potentialFocus

QedImage QedImageLoader(String url) {
  QedImage image = new QedImage();

/$QedImageLoader$this.image.img.onload = function() {
    _qedCallback(QedImageLoader$this, QedImageLoader$this.image);
  };
  QedImageLoader$this.image.img.onerror = function(event){
    _qedCallback(QedImageLoader$this, QedImageLoader$this.image);
  }
  QedImageLoader$this.image.img.src = url$/
}

void Widget_(Directive_ directive) {
  int[] group = []
  float[][] expandArray = 2 32 0
  int count = 0

  for (int ndx = 0; ndx < directive.atts.size(); ndx++)
    if (isAreaHeritable(directive.atts[ndx].code))
      pushAttribute(directive.atts[ndx].code, directive.atts[ndx].value)

  Widget_[] subWidgets = recalcWidgets()
  int[] size = subWidgets.size() ? subWidgets[subWidgets.size() - 1].group : [0, 0]
  var[] outWidget = []
  int outType = directive.outAttr.size() ? directive.outAttr[0].outType : -1;
  int outNumDim = outType >= 0 ? directive.outAttr[0].outNumDim : 0;

  if (outType >= 0) {
    var subModel = directive.outAttr[0].value

    if (/$subModel != null$/)
      if (outNumDim) {
        if (outType == 0) {
          var[] array = subModel
          ViewArray_ viewArray = new ViewArray_(array, array.getDirs(directive.direction), resizeViewObj, getViewSizeObj, paintViewObj, onViewEventObj, getViewElementRectObj)

          outWidget = [viewArray]
          size = viewArray.size
        }
        else
          if (outType == 1) {
            ViewArray_ viewArray = new ViewArray_(subModel, [directive.direction & 1, directive.direction & 2 ? 1 : 0], resizeViewString, getViewSizeString, paintViewString, onViewEventString, getViewElementRectString)

            outWidget = [viewArray]
            size = viewArray.size
          }
          else
            if (outType == 2) {
              ViewArray_ viewArray = new ViewArray_(subModel, [directive.direction & 1, directive.direction & 2 ? 1 : 0], resizeViewImage, getViewSizeImage, paintViewImage, onViewEventImage, getViewElementRectImage)

              outWidget = [viewArray]
              size = viewArray.size
            }
      }
      else
        if (outType == 0) {
          Window_[] window = _refreshViews(subModel)

          outWidget = window
          size = window.size() ? /$window[0].size$/ : [0, 0]
        }
        else
          if (outType == 1)
            size = getTextSize(subModel)
          else
            if (outType == 2)
              size = getImageSize(subModel)
  }

  if (directive.sizeAttr.size())
    size = i::2 getDirVar(i, directive.sizeAttr[0].value)

  for (int ndx = directive.atts.size() - 1; ndx >= 0; ndx--)
    if (isAreaHeritable(directive.atts[ndx].code))
      popAttribute(directive.atts[ndx].code)

  Widget_[] recalcWidgets() {
    Widget_[] subWidgets = i::directive.children.size() new Widget_(directive.children[i])
    Widget_[] previous = []

    for (int index = 0; index < subWidgets.size(); index++) {
      Widget_ sub = subWidgets[index]

      if (/$sub != null && sub.size$/ && hasAreas(sub.directive)) {
        int[] previousSize = previous.size() ? previous[0].group : [0, 0]

        sub.group = dir::2 (directive.direction & (1 << dir) ? previousSize[dir] + sub.size[dir] : max(previousSize[dir], sub.size[dir]))
        previous = [sub]
      }

      Attr_[] att = directive.children[index].findAttr(QED_TAG_EXPAND)

      if (att.size()) {
        for (int dir = 0; dir < 2; dir++)
          if (directive.direction & (1 << dir))
            expandArray[dir][count] = ((int) getDirVar(dir, att[0].value)) +  (count ? expandArray[dir][count - 1] : 0)

        count++;
      }
    }

    return subWidgets
  }

  void paint(int pos0, int pos1, int size0, int size1) {
    for (int ndx = 0; ndx < directive.atts.size(); ndx++) {
      Attr_ att = directive.atts[ndx];

      if (isHeritable(att.code)) {
        var value = att.value

        if (!isAreaHeritable(att.code) && att.outType > 2)
          value = /$value()$/

        if (att.code == QED_TAG_ROTATION) {
          // add rotation
          rotate(pos0, pos1, size0, size1, value)
          pos0 = -size0 / 2
          pos1 = -size1 / 2
        }
        else
          pushAttribute(att.code, value)
      }
    }

//    if (directive.changeLevel) {
      int outType = directive.outAttr.size() ? directive.outAttr[0].outType : -1;
      int outNumDim = outType >= 0 ? directive.outAttr[0].outNumDim : 0;

      if (outType >= 0 && /$directive.outAttr[0].value != null$/)
        if (outNumDim) {
          ViewArray_ viewArray = outWidget[0]

          if (viewArray)
            viewArray.paint(pos0, pos1, size0, size1);
        }
        else
          if (outType == 0) {
            Window_ window = outWidget[0]

            window.paint(pos0, pos1, size0, size1);
          }
          else
            if (outType == 1)
              displayText(directive.outAttr[0].value, pos0, pos1, size0, size1)
            else
              if (outType == 2)
                displayImage(directive.outAttr[0].value, pos0, pos1, size0, size1)
              else {
                drawFn *fn = directive.outAttr[0].value
                int lineWidth = /$_lineFlag ? ctx.lineWidth : 0$/
                int offset = lineWidth / 2

                fn(pos0 + offset, pos1 + offset, size0 - lineWidth, size1 - lineWidth)
              }
//    }

//    if (directive.subChangeLevel) {
      int subSize = subWidgets.size()
      int[] extraSpace = getExtraSpace([size0, size1])

      if (!outNumDim && outType >= 1)
        saveContext()

      for (int index = 0; index < subSize; index++) {
        Widget_ sub = subWidgets[index]

        if (/$sub && sub.size$/) {
          int[] rect = getChildArea(index, size0, size1, extraSpace)

          subWidgets[index].paint(pos0 + rect[0], pos1 + rect[1], rect[2], rect[3]);
        }
      }

      if (!outNumDim && outType >= 1)
        restoreContext()
//    }

    for (int ndx = directive.atts.size() - 1; ndx >= 0; ndx--)
      if (isHeritable(directive.atts[ndx].code))
        if (directive.atts[ndx].code == QED_TAG_ROTATION)
          restoreContext()
        else
          popAttribute(directive.atts[ndx].code)
  }

  bool onEvent(int event, int[] location, int[] size) {
//    if (!(directive._eventFlags & (1 << event)) != 0)
//      return false

    bool flag = false
    bool locationFlag = true

    for (int dir = 0; locationFlag && dir < 2; dir++)
      locationFlag = location[dir] >= 0 && location[dir] < size[dir]

    if (locationFlag) {
      int subSize = subWidgets.size()

      if (subSize) {
        int[] extraSpace = getExtraSpace(size)
        bool parse = true;

        for (int index = subSize - 1; !flag && parse && index >= 0; index--) {
          Widget_ sub = subWidgets[index]

          if (/$sub && sub.size$/) {
            int[] rect = getChildArea(index, size[0], size[1], extraSpace)

            flag = sub.onEvent(event, [location[0] - rect[0], location[1] - rect[1]], [rect[2], rect[3]])

            if (!flag && index && directive.direction) {
              bool inRect = true

              for (int dir = 0; inRect && dir < 2; dir++)
                inRect = location[dir] >= rect[dir] && location[dir] < rect[dir] + rect[2 + dir]

              parse = !inRect
            }
          }
        }
      }

      if (!flag && directive.outAttr.size())
        if (directive.outAttr[0].outNumDim) {
          ViewArray_ viewArray = outWidget[0]

          flag = viewArray.onEvent(event, location[0], location[1], size[0], size[1])
        }
        else
          if (directive.outAttr[0].outType == 0) {
            Window_ window = outWidget[0]

            flag = window.onEvent(event, location, size)
          }

      if (!flag) {
        int eventIndex = getEventIndex(event)

        if (eventIndex != -1) {
          QEDFocus_ focus = potentialFocus

          focus.adjust(/$Widget_$this$/, location, size)
          post_(directive.atts[eventIndex].value)
          flag = true
        }
      }
    }

    return flag
  }

  int[] getBoundsRect(String[] path, int[] index, int pos0, int pos1, int size0, int size1, int level, int dLevel) {
    Attr_[] tagName = directive.findAttr(QED_TAG_ID)

    if (tagName.size())
      if (path[level] == tagName[0].value) {
        level++

        if (level == path.size() && dLevel == index.size())
          return [pos0, pos1, size0, size1]
        else {
          if (directive.outAttr.size())
            if (directive.outAttr[0].outNumDim) {
              ViewArray_ viewArray = outWidget[0]

              return viewArray.getBoundsRect(path, index, pos0, pos1, size0, size1, level, dLevel)
            }
            else
              if (directive.outAttr[0].outType == 0) {
                Window_ window = outWidget[0]

                return window.getBoundsRect(path, index, pos0, pos1, size0, size1, level, dLevel)
              }

          return []
        }
      }

    int subSize = subWidgets.size()

    if (subSize) {
      int[] extraSpace = getExtraSpace([size0, size1])

      for (int ndx = 0; ndx < subSize; ndx++) {
        Widget_ sub = subWidgets[ndx]

        if (/$sub && sub.size$/) {
          int[] rect = getChildArea(ndx, size[0], size[1], extraSpace)
          int[] bounds = sub.getBoundsRect(path, index, pos0 + rect[0], pos1 + rect[1], rect[2], rect[3], level, dLevel)

          if (bounds.size())
            return bounds
        }
      }
    }

    return []
  }

  int getEventIndex(int event) {
    for (int index = 0; index < directive.atts.size(); index++) {
      int code = directive.atts[index].code;

      if (code < 0 && event == -code - 1)
        return index
    }

    return -1
  }

  int[] getExtraSpace(int[] totalSize) {
    int[] extraSpace = [0, 0]

    for (int dir = 0; dir < 2; dir++)
      if (directive.direction & (1 << dir)) {
        extraSpace[dir] = totalSize[dir] - (subWidgets.size() ? subWidgets[subWidgets.size() - 1].group[dir] : 0)

        if (directive.children.size() >= 2 && count && expandArray[dir][count - 1] > 1)
          extraSpace[dir] /= expandArray[dir][count - 1]
      }

    return extraSpace
  }

  int[] getChildArea(int index, int size0, int size1, int[] extraSpace) {
    int[] rect = [0, 0]

    for (int dir = 0; dir < 2; dir++)
      if ((directive.direction & (1 << dir)) != 0) {
        // add previous units expansion
        int ndx = -1

        for (int count = 0; count < index; count++)
          if (subWidgets[count].directive.findAttr(QED_TAG_EXPAND).size())
            ndx++

        if (ndx >= 0)
          rect[dir] = expandArray[dir][ndx] * extraSpace[dir]
      }

    return getChildArea2(subWidgets, directive.direction, index, rect[0], rect[1], size0, size1, extraSpace)
  }
}

int[] getChildArea2(Widget_[] subWidgets, int direction, int index, int pos0, int pos1, int size0, int size1, int[] extraSpace) {
  int[] rect = [pos0, pos1, size0, size1]
  Widget_ subWidget = subWidgets[index]
  Attr_[] expandAttr = subWidget.directive.findAttr(QED_TAG_EXPAND)
  Attr_[] alignAttr = subWidget.directive.findAttr(QED_TAG_ALIGN);
  Attr_[] posAttr = subWidget.directive.findAttr(QED_TAG_POS);

  for (int dir = 0; dir < 2; dir++) {
    if ((direction & (1 << dir)) != 0) {
      rect[2 + dir] = subWidget.group[dir]

      if (index) { // +
        int diff = subWidgets[index - 1].group[dir]

        rect[dir] += diff
        rect[2 + dir] -= diff
      }

      if (expandAttr.size())
        rect[2 + dir] += extraSpace[dir] * getDirVar(dir, expandAttr[0].value)
    }
    else {
      float originalSize = rect[2 + dir]
      float expansion = expandAttr.size() ? min(getDirVar(dir, expandAttr[0].value), 1) : subWidget.directive.findAttr(QED_TAG_SIZE).size() || alignAttr.size() ? 0 : 1

      rect[2 + dir] = subWidget.size[dir]

      if (expansion)
        rect[2 + dir] += (originalSize - rect[2 + dir]) * expansion

      if (alignAttr.size())
        rect[dir] += (originalSize - rect[2 + dir]) * getDirVar(dir, alignAttr[0].value)
    }

    if (posAttr.size())
      rect[dir] += getDirVar(dir, posAttr[0].value)
  }

  return rect
}

void QEDFocus_(Widget_ widget, int[] rect) {
  void adjust(Widget_ w, int[] location, int[] size) {
    widget = w
    rect[0] -= location[0]
    rect[1] -= location[1]
    rect[2] = size[0];
    rect[3] = size[1];
  }
}

QEDFocus_[] qedFocus = []

void _captureFocus() {
  qedFocus = [potentialFocus]
}

void _releaseFocus() {
  qedFocus = []
}

void onGlobalEvent(int event, int[] location) {
  if (/$!this.MainObj$/)
    return;

  if (qedFocus.size()) {
    int eventIndex = qedFocus[0].widget.getEventIndex(event);

    if (eventIndex != -1) {
      // remove Main_$this.qedFocus[0].rect[0] (and [1]) from location (ev.clientX - rect.left, ev.clientY - rect.top) here
      post_(qedFocus[0].widget.directive.atts[eventIndex].value)
    }
  }
  else {
    potentialFocus = new QEDFocus_(/$null$/, [location[0], location[1], 0, 0]);
    /$if (Main_$this.windows.length)
      Main_$this.windows[0].onEvent(event, location, [canvas.width, canvas.height])$/
  }

  if (/$postHandler$/)
    executeEvents_();
}

var getDirVar(int dir, var value) {
/$return value instanceof Array ? value[dir] : value$/
}

void Window_(Directive_[] ui, Window_[] dialog) {
  Widget_[] widgets = i::ui.size() new Widget_(ui[i])
  Widget_[] previous = []

  for (int index = 0; index < widgets.size(); index++) {
    Widget_ sub = widgets[index]

    if (/$sub && sub.size$/ && hasAreas(sub.directive)) {
      int[] previousSize = previous.size() ? previous[0].group : [0, 0]

      sub.group = dir::2 max(previousSize[dir], sub.size[dir])
      previous = [sub]
    }
  }

  int[] size = widgets.size() ? widgets[widgets.size() - 1].group : [0, 0]

  if (dialog.size())
    size = i::2 max(size[i], dialog[0].size[i])

  void paint(int pos0, int pos1, int size0, int size1) {
//    println("Repainting window " + pos0 + ", " + pos1 + ", " + size0 + ", " + size1)
    for (int index = 0; index < widgets.size(); index++) {
      Widget_ sub = widgets[index]

      if (/$sub && sub.size$/) {
        int[] rect = getChildArea2(widgets, 0, index, pos0, pos1, size0, size1, /$null$/)

        sub.paint(rect[0], rect[1], rect[2], rect[3])
      }
    }

    if (dialog.size())
      dialog[0].paint(pos0, pos1, size0, size1)
  }

  bool onEvent(int event, int[] location, int[] size) {
    bool flag = false

    if (dialog.size())
      flag = dialog[0].onEvent(event, location, size);
    else
      for (int index = widgets.size() - 1; !flag && index >= 0; index--) {
        Widget_ sub = widgets[index]

        if (/$sub && sub.size$/) {
          int[] rect = getChildArea2(widgets, 0, index, 0, 0, size[0], size[1], /$null$/)

          flag = sub.onEvent(event, [location[0] - rect[0], location[1] - rect[1]], [rect[2], rect[3]])
        }
      }

    return flag
  }

  int[] getBoundsRect(String[] path, int[] index, int pos0, int pos1, int size0, int size1, int level, int dLevel) {
    for (int ndx = 0; ndx < widgets.size(); ndx++) {
      Widget_ sub = widgets[ndx]

      if (/$sub && sub.size$/) {
        int[] rect = getChildArea2(widgets, 0, ndx, pos0, pos1, size0, size1, /$null$/)
        int[] bounds = sub.getBoundsRect(path, index, rect[0], rect[1], rect[2], rect[3], level, dLevel)

        if (bounds.size())
          return bounds;
      }
    }

    return dialog.size() ? dialog[0].getBoundsRect(path, index, pos0, pos1, size0, size1, level, dLevel) : []
  }
}

Window_[] _refreshViews(var obj) {
  Window_[] dialog = /$obj.blocking__Call$/ ? _refreshViews(/$obj.blocking__Call$/) : []

  return /$obj.qedModel$/ ? [new Window_(/$obj.qedModel$/, dialog)] : dialog
}

void QedWait(var[] array) {
  int count = array.size()

  for (int index = 0; index < count; index++) {
    Window_ obj = array[index]
    var oldHandler = /$obj._HandlerFn_$/

    obj -> {
      if (oldHandler)
        /$oldHandler()$/

      if (--count == 0)
        return
    }
  }
}

var[] QedWaitValues(var[] array) {
  int count = array.size()

  if (!count)
    return []

  var[] outputs = count 0;

  for (int index = 0; index < count; index++) {
    int ndx = index;
    SQEDArray obj = array[index]
    var oldHandler = /$obj._HandlerFn_$/

    obj -> {
      outputs[ndx] = _ret

      if (oldHandler)
        /$oldHandler(_ret)$/

      if (--count == 0)
        return outputs
    }
  }
}

var start_(var[] args, intHandler_ returnFn) {
  /$Main_$this.MainObj = _bindHandler(new this.Main(args, null), (function Lambda_(_ret) {
    Main_$this.MainObj._qedKill();
    Main_$this.MainObj = null;

    if (returnFn)
      returnFn(_ret);
  }))$/
  executeEvents_()
  return /$Main_$this.MainObj$/
}
